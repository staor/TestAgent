# GitHub Copilot 编码指南

## 一、项目规范

### 1.1 编程语言与风格
- **支持语言**：C、C++、Python、JavaScript、TypeScript
- **编码风格**：遵循各语言的官方规范
- **代码注释**：使用中文编写，便于团队理解
- **提交说明**：使用中文描述，清晰简明

### 1.2 文件组织结构
```
project/
├── src/                  # 源代码目录
│   ├── core/            # 核心模块
│   ├── utils/           # 工具函数
│   └── modules/         # 功能模块
├── include/             # 头文件目录
├── tests/               # 测试代码目录
├── docs/                # 文档目录
├── build/               # 编译输出
└── README.md            # 项目说明
```

### 1.3 版本管理规范
- **主分支**：`main` - 生产环境代码
- **开发分支**：`develop` - 开发中的代码
- **功能分支**：`feature/[功能名]` - 新功能开发
- **修复分支**：`bugfix/[问题号]` - 缺陷修复
- **发布分支**：`release/[版本号]` - 发布准备

---

## 二、命名规范

### 2.1 基础命名规则
| 类型 | 规则 | 示例 |
|------|------|------|
| 函数名 | snake_case | `calculate_sum()`, `process_data()` |
| 变量名 | snake_case | `user_count`, `is_valid` |
| 常量名 | UPPER_SNAKE_CASE | `MAX_SIZE`, `DEFAULT_TIMEOUT` |
| 类/结构体 | PascalCase | `UserManager`, `DataProcessor` |
| 枚举 | PascalCase | `ErrorCode`, `DeviceState` |
| 接口/抽象类 | I+PascalCase (C++) | `IDataReader` |

### 2.2 前缀与后缀约定
- **全局变量**：`g_` 前缀（如：`g_config_data`）
- **静态变量**：`s_` 前缀（如：`s_cache_pool`）
- **成员变量**：`m_` 前缀 (C++)（如：`m_buffer_size`）
- **指针变量**：`p_` 前缀（如：`p_node`）
- **布尔变量**：`is_`/`has_` 前缀（如：`is_enabled`, `has_children`）
- **回调函数**：`on_` 前缀（如：`on_button_click()`）

### 2.3 文件命名
- **头文件**：`*.h` 或 `*.hpp`（如：`data_manager.h`）
- **源文件**：`*.c` 或 `*.cpp`（如：`data_manager.cpp`）
- **测试文件**：`test_*.c` 或 `*_test.c`
- **所有字母小写**，使用下划线分隔

---

## 三、代码结构与风格

### 3.1 函数设计原则
- **单一职责**：每个函数只做一件事
- **简洁性**：函数体不超过 50 行代码（目标）
- **参数限制**：参数不超过 5 个，超过使用结构体
- **返回值**：清晰表达函数执行结果
- **文档**：所有函数必须有说明注释

函数头部注释示例：
```c
// 功能：计算两个数字的和
// 参数：a - 第一个数字，b - 第二个数字
// 返回：a 和 b 的和
// 注意：不处理整数溢出
int32_t add_numbers(int32_t a, int32_t b);
```

### 3.2 代码注释规范
- **注释率**：10-20% 为佳，过多或过少都不好
- **复杂逻辑**：必须添加步骤说明注释
- **业务逻辑**：解释 "为什么" 而不只是 "做什么"
- **避免注释**：不要注释很明显的代码

良好注释示例：
```c
// 使用二分查找是为了性能考虑（时间复杂度 O(log n)）
int index = binary_search(array, target);
```

不好的注释示例：
```c
i = i + 1;  // i 加 1
```

### 3.3 控制流规范
- **嵌套深度**：最多 3 层，超过使用提前返回
- **卫语句**：使用卫语句简化逻辑
- **switch优于if**：选择使用时优先 switch
- **保持简洁**：避免复杂的条件表达式

卫语句示例：
```c
void process_user(User *user) {
    if (user == NULL) return;              // 卫语句
    if (user->age < 0) return;
    
    // 主逻辑处理
    do_process(user);
}
```

### 3.4 代码格式规范
- **缩进**：4 个空格（或 1 个 Tab，保持一致）
- **行长度**：不超过 120 个字符
- **大括号**：与语句同行（1TBS 风格）
- **空行**：逻辑段之间插入空行，增强可读性
- **空格**：操作符两侧加空格

代码格式示例：
```c
if (condition) {
    // 代码块
    function_call();
} else {
    // 代码块
}

// 逻辑段之间加空行

for (int i = 0; i < count; i++) {
    process(i);
}
```

---

## 四、错误处理

### 4.1 异常管理策略
- **检查所有输入**：验证参数有效性
- **返回错误码**：C/C++ 通过返回值表达错误（不使用异常）
- **清晰消息**：错误信息要明确、有助于调试

错误处理示例：
```c
#define ERROR_NULL_POINTER (-1)
#define ERROR_INVALID_SIZE (-2)
#define SUCCESS (0)

int allocate_buffer(uint8_t **buffer, size_t size) {
    if (buffer == NULL) return ERROR_NULL_POINTER;
    if (size == 0) return ERROR_INVALID_SIZE;
    
    *buffer = malloc(size);
    if (*buffer == NULL) return ERROR_OUT_OF_MEMORY;
    
    return SUCCESS;
}
```

### 4.2 日志记录规范
- **日志级别**：DEBUG、INFO、WARNING、ERROR、FATAL
- **包含上下文**：时间戳、模块名、错误代码
- **避免过多日志**：仅记录关键操作
- **不记录敏感信息**：密码、token、隐私数据

日志记录示例：
```c
LOG_ERROR("[DB] Database connection failed. Code: %d", error_code);
LOG_INFO("[AUTH] User login successful. UserID: %llx", user_id);
```

### 4.3 资源释放规范
- **RAII 模式**：C++ 使用构造/析构自动管理资源
- **配对申请与释放**：malloc/free、open/close 配对
- **异常安全**：即使发生错误也要释放资源
- **清理函数**：C 语言使用明确的清理函数

资源释放示例：
```c
int process_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) return ERROR_OPEN_FILE;
    
    // ... 处理文件 ...
    
    int result = do_work(file);
    fclose(file);  // 必须释放
    
    return result;
}
```

---

## 五、性能优化

### 5.1 内存管理
- **防止泄漏**：每次 malloc 都要配对 free
- **合适数据结构**：根据场景选择（数组、链表、树等）
- **大数据处理**：考虑流式处理或分块处理
- **内存池**：频繁分配使用内存池优化
- **缓冲复用**：避免频繁申请释放

### 5.2 算法选择
- **时间复杂度**：O(1) > O(log n) > O(n) > O(n log n) > O(n²)
- **空间权衡**：必要时用空间换时间
- **避免重复计算**：使用缓存、备忘录模式
- **选择合适算法**：排序、查找、递归等

### 5.3 代码优化建议
- **消除冗余代码**：提取公共逻辑
- **编译器优化**：使用 `-O2` 或 `-O3` 优化选项
- **微观优化**：避免频繁函数调用、内存访问
- **定期分析**：使用 profiler 找出性能瓶颈

---

## 六、代码审查

### 6.1 自检清单（提交前必读）
- [ ] **功能完整**：所有需求均已实现
- [ ] **命名规范**：遵循命名约定
- [ ] **注释清晰**：重要逻辑有注释
- [ ] **错误处理**：所有错误情况已处理
- [ ] **内存安全**：无内存泄漏、野指针
- [ ] **性能考虑**：没有明显的性能问题
- [ ] **测试通过**：单元测试全部通过
- [ ] **代码重复**：没有过多重复代码

### 6.2 Code Review 流程
1. **提交前**：自我检查（使用上述清单）
2. **创建 PR**：描述改动内容和原因
3. **代码审查**：至少 1 人审核，2 人批准合并
4. **反馈改进**：及时处理审查意见
5. **最终合并**：确保所有意见已解决

---

## 七、测试规范

### 7.1 测试原则
- **及早测试**：边开发边测试
- **覆盖率目标**：>80%（关键代码 >90%）
- **独立性**：测试之间相互独立
- **可重复性**：测试结果可再现
- **自动化**：使用测试框架自动化

### 7.2 测试类型
- **单元测试**：测试单个函数，使用 CUnit、GTest 等
- **集成测试**：测试模块间交互和数据流
- **系统测试**：端到端黑盒测试
- **性能测试**：测试响应时间、内存占用
- **回归测试**：确保修复未引入新 bug

测试示例（使用 CUnit）：
```c
void test_add_positive_numbers() {
    int result = add_numbers(5, 3);
    CU_ASSERT_EQUAL(result, 8);
}

void test_add_with_negative() {
    int result = add_numbers(-5, 3);
    CU_ASSERT_EQUAL(result, -2);
}
```

---

## 八、文档要求

### 8.1 代码文档
- **函数文档**：参数、返回值、异常情况
- **类/模块文档**：用途、主要接口、使用示例
- **复杂算法**：详细说明思路和实现步骤
- **变更日志**：记录重要改动

### 8.2 项目文档
| 文件 | 内容 |
|------|------|
| README.md | 项目概述、快速开始、功能列表 |
| CHANGELOG.md | 版本记录、新增功能、bug 修复 |
| CONTRIBUTING.md | 贡献指南、开发流程、代码规范 |
| API.md | API 文档、数据结构、使用案例 |
| INSTALL.md | 安装说明、依赖项、配置步骤 |
| FAQ.md | 常见问题、故障排除 |

### 8.3 开发文档
- **架构设计**：系统设计、模块划分、接口定义
- **数据流图**：清晰展示数据流向
- **时序图**：关键流程的执行顺序
- **部署说明**：环境配置、部署步骤

---

## 九、最佳实践

### 9.1 代码复用
- **DRY 原则**：不要重复代码（Don't Repeat Yourself）
- **提取函数**：3+ 次使用相同代码就要提取
- **使用库**：充分利用标准库和第三方库
- **设计模式**：合理使用工厂、策略等模式

### 9.2 可维护性
- **代码简洁**：简洁的代码更容易维护
- **低耦合**：模块间减少依赖关系
- **高内聚**：模块内部功能紧密相关
- **向后兼容**：修改时保持接口稳定

### 9.3 安全性
- **input 验证**：检查所有输入数据
- **缓冲溢出**：防止 buffer overflow
- **注入攻击**：防止 SQL 注入、命令注入
- **安全函数**：使用 strncpy 替代 strcpy

---

## 十、常见错误集锦

❌ **应避免的做法：**
- 函数过长（>100 行）
- 参数过多（>5 个）
- 嵌套过深（>3 层）
- 没有错误处理
- 内存泄漏
- 魔法数字（直接写 8、16、255 等）
- 全局变量滥用
- 注释过多或太少

✅ **正确的做法：**
- 单一职责，函数简洁
- 参数适量，超过用结构体
- 使用卫语句降低嵌套
- 完善的错误处理
- 及时释放资源
- 使用命名常量
- 最小化全局变量使用范围
- 注释说明复杂逻辑